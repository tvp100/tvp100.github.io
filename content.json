{"pages":[],"posts":[{"title":"破解百度云下载限制","text":"本教程通过使用Tampermonkey脚本管理工具+IDM破解来实现破解下载速度的限制 本教程使用的是谷歌游览器 更新了访问谷歌商店的方法 https://github.com/haotian-wang/google-access-helper 具体参照上面链接里的仓库 图片提示： 1.下载Tampermonkey脚本管理工具下载链接(网站是谷歌商店!)：https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en 下载完成后点击谷歌浏览器右上角的三个点→更多→拓展 点击按钮启动脚本管理工具（如果默认是安装完自动启动的，就不用管了） 成功安装后右上角会出现小图标， 红色箭头的按钮：启动脚本管理工具 蓝色箭头的按钮：进入脚本管理的页面 下图的脚本管理的界面，我们需要安装图中所示的脚本 2.进入脚本网站下载脚本脚本链接(国内可以直接访问)：https://greasyfork.org/zh-CN/scripts 点击箭头旁边的安装按钮进行安装（我已经装过了所以是这个按钮） 安装后请进入脚本管理界面启动脚本（如果默认开启就不用管了） 安装好脚本后，我们还需要一个下载工具配合脚本的使用 3.下载IDM工具IDM下载链接(国内可以直接访问,但下载速度可能很慢)：https://www.internetdownloadmanager.com/ 点击图中的按钮进行下载 安装位置选择默认的设置就行（文件很小，放心装C盘吧） 后续可以选择文件下载后的保存位置！！！ 安装全部点是就行了，点完了就X掉窗口 安装完成后需要重启谷歌浏览器 软件注册什么的不用管，失效了就重装或者百度解决 重启后会出现这个按钮表示成功，如果没有点击谷歌浏览器右上角的三个点→更多→拓展（第一点里有图片）进入管理界面，手动打开脚本 注：IDM会开机自启动，软件很小，几乎不占用空间，卸载IDM可解决，博主也不知道有没有什么别的方法。。 4.如何使用工具上面几步做完后就可以进行下载啦 请确保IDM在后台运行 1.点击图中的显示直链 如果没有这个东西，请先看看右上角的这个脚本管理工具有没有1个小红点，有代表脚本启动成功了，没有就是你脚本还未启动或者失败了。 这个需要你登陆百度云的账号才能使用（不需要vip账号），这是百度设定的，不会影响破解下载 2.直接点击跳出来的链接 3.自动跳转到下载工具 在红框内选择你文件要下载的位置，选择好后点击开始即可享受高速下载啦。 几乎大部分的文件都可以通过这种方式下载，少部分不能下载的，请更换别的下载方式，下载过程中最好不要暂停，最好一次性下载完","link":"/2019/10/25/Tampermonkey-pandowm/"},{"title":"npm的安装和配置","text":"npm的github官方 README 文档翻译翻译时间 2020/5/12官方文档网站 npm(1) – 一个 JavaScript 的包管理器概要 这里有足够的信息帮助你正常npm. 在npm安装好后，你可以用 npm help 命令来获取更多的帮助信息. 重点 你需要 node v6 或者更高的版本来运行这个程序. 要安装一个用 node v5 或者更早的旧的不再提供支持的 npm 版本，你可以点击旧的标签和分支. npm的默认配置仓库是https://registry.npmjs.org.使用默认仓库必须遵守的条例https://www.npmjs.com/policies/terms. npm的仓库可以被设置为任何你想要的仓库，甚至是你自己的仓库.查看文档来获取自定义仓库的配置信息doc on registries. 超级容易安装 npm需要node环境node. Windows系统获取 MSI . npm 在这里面. 苹果系统获取 pkg. npm 在这里面. 其他类型的系统运行 make install. npm 将会通过node安装. 如果你想要花式的安装 (a different version, customizedpaths, etc.) 请阅读它. 花式安装 (Unix) 这里 有一个非常强大的安装脚本https://www.npmjs.com/install.sh. 你可以下载并运行他. 这是一个使用 curl 的例子: 1curl -L https://www.npmjs.com/install.sh | sh 进阶花式安装你可以修改任何npm配置通过这个脚本: 1npm_config_prefix=/some/path sh install.sh 或者你可以用超级调试模式运行他 1npm_debug=1 sh install.sh 超级花式安装用git下载代码, 使用 make 命令建立文档并做其他事情. 如果你打算黑掉npm, make link命令会帮到你. 如果你已经得到了npm源代码, 你可以半永久的设置任意配置关键词通过./configure --key=val ..., 然后运行命令node bin/npm-cli.js &lt;command&gt; &lt;args&gt;. (这可以让你测试或者做任何事而不需要真正的安装npm本身.) Windows安装和升级 npm 3 对Windows用户做了很对改进 - 如果使用了最近的一个npm版本, 你可以流畅的运行它. 想要升级, 既可以用 微软升级工具, 下载一个新版本的node, 也可以在 Installing/upgrading npm 里找到更新指南. 如果这对你来说还不花哨, 你可以通过git下载代码, 然后随便使用它们. 在 Cygwin 上安装 不! 卸载 非常悲伤看到你卸载它 1sudo npm uninstall npm -g 如果它失败了 1sudo make uninstall 更多服务的卸载 通常以上说明已经足够了, 它可以卸载 npm, 但是会保留任何你安装的东西. 如果你想要移除所有通过npm安装的包, 你可以用 npm ls 命令来找到他们, 然后运行 npm rm 来移除他们. 为了移除旧的包, 你可以用命令 clean-old.sh . 你可以像这样运行 1npm explore npm -g -- sh scripts/clean-old.sh npm使用2个配置文件, 一个是个人用户配置, 一个是全局设置, 你可以运行命令来找到他们. 12npm config get userconfig # defaults to ~/.npmrcnpm config get globalconfig # defaults to /usr/local/etc/npmrc 默认情况下卸载npm不会移除任何配置, 你必须手动删除他们. 要注意一旦删除配置之后的 npm installs 不会使用你之前已经设置好的配置文件. 更多文档 看看 docs. 你可以运行 npm help 来获取. 如果你是一个开发者, 并且你希望用npm发布你的项目, 你应该 阅读它. BUGS当你发现的时候, 请报告他们: 网站:https://npm.community/c/bugs 确保包含所有的npm报错信息. npm-debug.log 文件可以给你提供相关信息. 也可以看看 npm(1) npm-help(1)","link":"/2020/05/12/npm%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"title":"1.选择排序和插入排序","text":"选择排序和插入排序是第一个学习的算法 希尔排序是第一个进阶算法 先来看看选择排序 123456789101112131415public class Selection{ public static void sort(Comparable[] a) { // 将a[]按升序排列 int N = a.length; // 数组长度 for (int i = 0; i &lt; N; i++) { // 将a[i]和a[i+1..N]中最小的元素交换 int min = i; // 最小元素的索引 for (int j = i+1; j &lt; N; j++) if (less(a[j], a[min])) min = j; exch(a, i, min); } }// less()、exch()、isSorted()和main()方法见“排序算法类模板”} 选择排序是通过每一次都扫描整个数组，依次找出最小（大）的数排到前（后）面，由于每次移动数据后原数组还是无序的，所以交换的次数是固定的，因此选择排序效率最低 插入排序对此进行了优化 12345678910111213public class Insertion{ public static void sort(Comparable[] a) { // 将a[]按升序排列 int N = a.length; for (int i = 1; i &lt; N; i++) { // 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中 for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--) exch(a, j, j-1); } }// less()、exch()、isSorted()和main()方法见“排序算法类模板”} 插入排序从左边开始循坏，i=1时只比较0和1两个位置，此时从0到i的位置是有序的，当i递增时，i会依次和他左边的数进行比较，如果满足条件就交换，由于i左边的数据永远是有序的，因此交换的次数随原数组的有序性决定，并不会像选择排序一样的固定的，最好的情况下，对一个排序好的数组进行插入排序，一次交换都不会发生。 希尔排序对插入排序进行了优化，选择排序每次通过j–来位移元素，只有1个偏移量，而希尔排序通过位移h个偏移量先进行排序，然后慢慢减小h直到偏移量为1。 在偏移量为h时，数组是部分有序的，由于其部分有序性，当h减小后，需要再次发生的位移次数会显著减少，因此提升了插入排序的效率。 1234567891011121314151617181920212223242526public class Shell{ public static void sort ( Comparable[] a ) { // 将a[]按升序排列 int N = a.length; int h = 1; while ( h &lt; N/3 ) { h = 3*h + 1; } // 1, 4, 13, 40, 121, 364, 1093, ... while ( h &gt;= 1 ) { // 将数组变为h有序 for ( int i = h; i &lt; N; i++ ) { // 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中 for ( int j = i; j &gt;= h &amp;&amp; less ( a[j], a[j-h] ); j -= h ) { exch ( a, j, j-h ); } } h = h/3; } } // less()、exch()、isSorted()和main()方法见“排序算法类模板”}","link":"/2020/08/23/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"破解","slug":"破解","link":"/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"破解","slug":"破解","link":"/categories/%E7%A0%B4%E8%A7%A3/"},{"name":"翻译","slug":"翻译","link":"/categories/%E7%BF%BB%E8%AF%91/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}