{"pages":[],"posts":[{"title":"2.归并排序和快速排序","text":"归并排序和快速排序是进阶的2个算法 1.归并排序先来看看归并排序 归并排序是对2个有序的子序列进行归并，合并成一个大的序列。 1234567891011public static void merge(Comparable[] a, int lo, int mid, int hi){ // 将a[lo..mid] 和 a[mid+1..hi] 归并 int i = lo, j = mid+1; for (int k = lo; k &lt;= hi; k++) // 将a[lo..hi]复制到aux[lo..hi] aux[k] = a[k]; for (int k = lo; k &lt;= hi; k++) // 归并回到a[lo..hi] if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi ) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++];} 这是归并排序的抽象方法，先将所有元素复制到aux中，然后依次归并左边和右边的元素，通过less(aux[j], aux[i])方法比较左右两个子序列中最小（大）的值，然后赋值给a中最左边的位置，当i&gt;mid，左子序列已经完成归并，此时不用再比较，直接将右子序列依次赋值给a数组。同理j&gt;hi时右子序列已经归并完毕，只需要把左子序列赋值给原数组就行。 然后是用了分治思想的归并 1234567891011121314151617public class Merge{ private static Comparable[] aux; // 归并所需的辅助数组 public static void sort(Comparable[] a) { aux = new Comparable[a.length]; // 一次性分配空间 sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { // 将数组a[lo..hi]排序 if (hi &lt;= lo) return; int mid = lo + (hi - lo)/2; sort(a, lo, mid); // 将左半边排序 sort(a, mid+1, hi); // 将右半边排序 merge(a, lo, mid, hi); // 归并结果（代码见“原地归并的抽象方法”） }} 把大数组分割成一对对的小数组进行归并。 因为递归会使小规模问题中方法的调用过于频繁，所以改进对它们的处理方法就能改进整个算法。因此在归并排序中对于分割的比较小的数组可以直接用插入排序来提升性能。 同时还有递推的归并算法，先处理最小的数组，然后依次处理大数组。 归并排序的进阶是原地归并排序，这种方法不需要借助额外的空间aux数组，节约了资源。下面是它的实现。 d中关键部分是先用index记录j之前的位置，然后移动指针j直到找到比i大的数，把index至j部分移动到i处。 e中的移动index至j部分代码如下 1234567//循环左移n位 n = j - indexvoid exchange(int[] a,int i,int j,int n){ reverse(a,i,j-n-1);//反转index左边 reverse(a,j-n,j);//反转index右边 reverse(a,i,j);//反转整个数组} 通过三次反转可以快速把index至j部分移到左边。 2.快速排序快排是现在应用最广泛的算法，它实现简单、适用于各种不同的场景、效率又高。 快排的核心思想是把一个数组分成两部分，从数组中随机找一个数k，使k左边的数全小于它，右边的数全大于它。然后分别对左右两边进行排序，即可得到有序的数组。运用分治的思想后可以多次分割左右两边的数组，当数组比较小时用插入排序进行排序，可以极大提升排序效率。 代码实现如下： 123456789101112131415public class Quick{ public static void sort(Comparable[] a) { StdRandom.shuffle(a); // 消除对输入的依赖 sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (hi &lt;= lo) return; int j = partition(a, lo, hi); // 切分（请见“快速排序的切分”） sort(a, lo, j-1); // 将左半部分a[lo .. j-1]排序 sort(a, j+1, hi); // 将右半部分a[j+1 .. hi]排序 }} 快排切分找到数k部分代码 1234567891011121314private static int partition(Comparable[] a, int lo, int hi){ // 将数组切分为a[lo..i-1], a[i], a[i+1..hi] int i = lo, j = hi+1; // 左右扫描指针 Comparable v = a[lo]; // 切分元素 while (true) { // 扫描左右，检查扫描是否结束并交换元素 while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; if (i &gt;= j) break; exch(a, i, j); } exch(a, lo, j); // 将v = a[j]放入正确的位置 return j; // a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi] 达成} 下面的快排的进阶，详细内容略。","link":"/2020/09/07/2-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"破解百度云下载限制","text":"本教程通过使用Tampermonkey脚本管理工具+IDM破解来实现破解下载速度的限制 本教程使用的是谷歌游览器 更新了访问谷歌商店的方法 https://github.com/haotian-wang/google-access-helper 具体参照上面链接里的仓库 图片提示： 1.下载Tampermonkey脚本管理工具下载链接(网站是谷歌商店!)：https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en 下载完成后点击谷歌浏览器右上角的三个点→更多→拓展 点击按钮启动脚本管理工具（如果默认是安装完自动启动的，就不用管了） 成功安装后右上角会出现小图标， 红色箭头的按钮：启动脚本管理工具 蓝色箭头的按钮：进入脚本管理的页面 下图的脚本管理的界面，我们需要安装图中所示的脚本 2.进入脚本网站下载脚本脚本链接(国内可以直接访问)：https://greasyfork.org/zh-CN/scripts 点击箭头旁边的安装按钮进行安装（我已经装过了所以是这个按钮） 安装后请进入脚本管理界面启动脚本（如果默认开启就不用管了） 安装好脚本后，我们还需要一个下载工具配合脚本的使用 3.下载IDM工具IDM下载链接(国内可以直接访问,但下载速度可能很慢)：https://www.internetdownloadmanager.com/ 点击图中的按钮进行下载 安装位置选择默认的设置就行（文件很小，放心装C盘吧） 后续可以选择文件下载后的保存位置！！！ 安装全部点是就行了，点完了就X掉窗口 安装完成后需要重启谷歌浏览器 软件注册什么的不用管，失效了就重装或者百度解决 重启后会出现这个按钮表示成功，如果没有点击谷歌浏览器右上角的三个点→更多→拓展（第一点里有图片）进入管理界面，手动打开脚本 注：IDM会开机自启动，软件很小，几乎不占用空间，卸载IDM可解决，博主也不知道有没有什么别的方法。。 4.如何使用工具上面几步做完后就可以进行下载啦 请确保IDM在后台运行 1.点击图中的显示直链 如果没有这个东西，请先看看右上角的这个脚本管理工具有没有1个小红点，有代表脚本启动成功了，没有就是你脚本还未启动或者失败了。 这个需要你登陆百度云的账号才能使用（不需要vip账号），这是百度设定的，不会影响破解下载 2.直接点击跳出来的链接 3.自动跳转到下载工具 在红框内选择你文件要下载的位置，选择好后点击开始即可享受高速下载啦。 几乎大部分的文件都可以通过这种方式下载，少部分不能下载的，请更换别的下载方式，下载过程中最好不要暂停，最好一次性下载完","link":"/2019/10/25/Tampermonkey-pandowm/"},{"title":"npm的安装和配置","text":"npm的github官方 README 文档翻译翻译时间 2020/5/12官方文档网站 npm(1) – 一个 JavaScript 的包管理器概要 这里有足够的信息帮助你正常npm. 在npm安装好后，你可以用 npm help 命令来获取更多的帮助信息. 重点 你需要 node v6 或者更高的版本来运行这个程序. 要安装一个用 node v5 或者更早的旧的不再提供支持的 npm 版本，你可以点击旧的标签和分支. npm的默认配置仓库是https://registry.npmjs.org.使用默认仓库必须遵守的条例https://www.npmjs.com/policies/terms. npm的仓库可以被设置为任何你想要的仓库，甚至是你自己的仓库.查看文档来获取自定义仓库的配置信息doc on registries. 超级容易安装 npm需要node环境node. Windows系统获取 MSI . npm 在这里面. 苹果系统获取 pkg. npm 在这里面. 其他类型的系统运行 make install. npm 将会通过node安装. 如果你想要花式的安装 (a different version, customizedpaths, etc.) 请阅读它. 花式安装 (Unix) 这里 有一个非常强大的安装脚本https://www.npmjs.com/install.sh. 你可以下载并运行他. 这是一个使用 curl 的例子: 1curl -L https://www.npmjs.com/install.sh | sh 进阶花式安装你可以修改任何npm配置通过这个脚本: 1npm_config_prefix=/some/path sh install.sh 或者你可以用超级调试模式运行他 1npm_debug=1 sh install.sh 超级花式安装用git下载代码, 使用 make 命令建立文档并做其他事情. 如果你打算黑掉npm, make link命令会帮到你. 如果你已经得到了npm源代码, 你可以半永久的设置任意配置关键词通过./configure --key=val ..., 然后运行命令node bin/npm-cli.js &lt;command&gt; &lt;args&gt;. (这可以让你测试或者做任何事而不需要真正的安装npm本身.) Windows安装和升级 npm 3 对Windows用户做了很对改进 - 如果使用了最近的一个npm版本, 你可以流畅的运行它. 想要升级, 既可以用 微软升级工具, 下载一个新版本的node, 也可以在 Installing/upgrading npm 里找到更新指南. 如果这对你来说还不花哨, 你可以通过git下载代码, 然后随便使用它们. 在 Cygwin 上安装 不! 卸载 非常悲伤看到你卸载它 1sudo npm uninstall npm -g 如果它失败了 1sudo make uninstall 更多服务的卸载 通常以上说明已经足够了, 它可以卸载 npm, 但是会保留任何你安装的东西. 如果你想要移除所有通过npm安装的包, 你可以用 npm ls 命令来找到他们, 然后运行 npm rm 来移除他们. 为了移除旧的包, 你可以用命令 clean-old.sh . 你可以像这样运行 1npm explore npm -g -- sh scripts/clean-old.sh npm使用2个配置文件, 一个是个人用户配置, 一个是全局设置, 你可以运行命令来找到他们. 12npm config get userconfig # defaults to ~/.npmrcnpm config get globalconfig # defaults to /usr/local/etc/npmrc 默认情况下卸载npm不会移除任何配置, 你必须手动删除他们. 要注意一旦删除配置之后的 npm installs 不会使用你之前已经设置好的配置文件. 更多文档 看看 docs. 你可以运行 npm help 来获取. 如果你是一个开发者, 并且你希望用npm发布你的项目, 你应该 阅读它. BUGS当你发现的时候, 请报告他们: 网站:https://npm.community/c/bugs 确保包含所有的npm报错信息. npm-debug.log 文件可以给你提供相关信息. 也可以看看 npm(1) npm-help(1)","link":"/2020/05/12/npm%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"title":"1.选择排序和插入排序","text":"选择排序和插入排序是第一个学习的算法 希尔排序是第一个进阶算法 先来看看选择排序 123456789101112131415public class Selection{ public static void sort(Comparable[] a) { // 将a[]按升序排列 int N = a.length; // 数组长度 for (int i = 0; i &lt; N; i++) { // 将a[i]和a[i+1..N]中最小的元素交换 int min = i; // 最小元素的索引 for (int j = i+1; j &lt; N; j++) if (less(a[j], a[min])) min = j; exch(a, i, min); } }// less()、exch()、isSorted()和main()方法见“排序算法类模板”} 选择排序是通过每一次都扫描整个数组，依次找出最小（大）的数排到前（后）面，由于每次移动数据后原数组还是无序的，所以交换的次数是固定的，因此选择排序效率最低 插入排序对此进行了优化 12345678910111213public class Insertion{ public static void sort(Comparable[] a) { // 将a[]按升序排列 int N = a.length; for (int i = 1; i &lt; N; i++) { // 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中 for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--) exch(a, j, j-1); } }// less()、exch()、isSorted()和main()方法见“排序算法类模板”} 插入排序从左边开始循坏，i=1时只比较0和1两个位置，此时从0到i的位置是有序的，当i递增时，i会依次和他左边的数进行比较，如果满足条件就交换，由于i左边的数据永远是有序的，因此交换的次数随原数组的有序性决定，并不会像选择排序一样的固定的，最好的情况下，对一个排序好的数组进行插入排序，一次交换都不会发生。 希尔排序对插入排序进行了优化，选择排序每次通过j–来位移元素，只有1个偏移量，而希尔排序通过位移h个偏移量先进行排序，然后慢慢减小h直到偏移量为1。 在偏移量为h时，数组是部分有序的，由于其部分有序性，当h减小后，需要再次发生的位移次数会显著减少，因此提升了插入排序的效率。 1234567891011121314151617181920212223242526public class Shell{ public static void sort ( Comparable[] a ) { // 将a[]按升序排列 int N = a.length; int h = 1; while ( h &lt; N/3 ) { h = 3*h + 1; } // 1, 4, 13, 40, 121, 364, 1093, ... while ( h &gt;= 1 ) { // 将数组变为h有序 for ( int i = h; i &lt; N; i++ ) { // 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中 for ( int j = i; j &gt;= h &amp;&amp; less ( a[j], a[j-h] ); j -= h ) { exch ( a, j, j-h ); } } h = h/3; } } // less()、exch()、isSorted()和main()方法见“排序算法类模板”}","link":"/2020/08/23/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"破解","slug":"破解","link":"/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"破解","slug":"破解","link":"/categories/%E7%A0%B4%E8%A7%A3/"},{"name":"翻译","slug":"翻译","link":"/categories/%E7%BF%BB%E8%AF%91/"}]}